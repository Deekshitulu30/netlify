<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Task Spinner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, addDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase log level for debugging
        setLogLevel('debug');
        
        // --- GLOBAL FIREBASE VARIABLES ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-student-spinner-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let db;
        let auth;
        let userId = 'loading'; // Default state before auth is ready
        let unsubscribeTasks;

        // --- APP STATE ---
        let tasks = [];
        const taskListContainer = document.getElementById('task-list-container');
        const wheelCanvas = document.getElementById('wheelCanvas');
        const ctx = wheelCanvas.getContext('2d');
        const spinButton = document.getElementById('spinButton');
        const resultDisplay = document.getElementById('resultDisplay');
        const loadingIndicator = document.getElementById('loadingIndicator');

        // --- UTILITY FUNCTIONS ---
        const today = new Date().toISOString().split('T')[0];

        // --- FIREBASE INITIALIZATION AND AUTH ---

        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in logic
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('userIdDisplay').textContent = `User ID: ${userId.substring(0, 8)}...`;
                        console.log("Firebase Auth Ready. User ID:", userId);
                        setupFirestoreListener();
                    } else {
                        // Should not happen in this environment, but good practice
                        console.log("No user signed in.");
                        userId = 'anonymous';
                    }
                    loadingIndicator.classList.add('hidden');
                });
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                loadingIndicator.textContent = 'Error loading app. Check console.';
                loadingIndicator.classList.remove('text-indigo-500');
                loadingIndicator.classList.add('text-red-500');
            }
        }

        function getCollectionRef() {
            return collection(db, 'artifacts', appId, 'users', userId, 'student-tasks');
        }

        function setupFirestoreListener() {
            if (unsubscribeTasks) {
                unsubscribeTasks(); // Clean up previous listener if switching users
            }

            const tasksQuery = query(getCollectionRef());

            unsubscribeTasks = onSnapshot(tasksQuery, (snapshot) => {
                const newTasks = [];
                snapshot.forEach((doc) => {
                    newTasks.push({ id: doc.id, ...doc.data() });
                });
                
                // Sort tasks by due date (Time Table view integration)
                newTasks.sort((a, b) => {
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1; // Incomplete first
                    }
                    return new Date(a.dueDate) - new Date(b.dueDate); // Then by date
                });

                tasks = newTasks;
                renderTaskList();
                drawWheel();
            }, (error) => {
                console.error("Error listening to tasks:", error);
            });
        }

        // --- TASK MANAGEMENT FUNCTIONS ---

        async function addTask(name, dueDate) {
            if (!name.trim()) return;

            const newTask = {
                name: name.trim(),
                dueDate: dueDate || today,
                completed: false,
                createdAt: new Date().toISOString()
            };

            try {
                await addDoc(getCollectionRef(), newTask);
                console.log("Task added successfully.");
            } catch (error) {
                console.error("Error adding document:", error);
            }
        }

        async function toggleTaskCompletion(taskId, currentStatus) {
            const taskDocRef = doc(getCollectionRef(), taskId);
            try {
                await updateDoc(taskDocRef, {
                    completed: !currentStatus,
                });
                console.log(`Task ${taskId} completion toggled to ${!currentStatus}`);
            } catch (error) {
                console.error("Error updating document:", error);
            }
        }

        async function deleteTask(taskId) {
            const taskDocRef = doc(getCollectionRef(), taskId);
            if (confirm("Are you sure you want to delete this task?")) {
                 try {
                    await deleteDoc(taskDocRef);
                    console.log(`Task ${taskId} deleted.`);
                } catch (error) {
                    console.error("Error deleting document:", error);
                }
            }
        }

        function handleTaskFormSubmit(event) {
            event.preventDefault();
            const taskNameInput = document.getElementById('taskNameInput');
            const taskDateInput = document.getElementById('taskDateInput');
            addTask(taskNameInput.value, taskDateInput.value);
            taskNameInput.value = ''; // Clear input
            taskDateInput.value = today;
        }

        // --- RENDERING FUNCTIONS ---

        function renderTaskList() {
            taskListContainer.innerHTML = '';
            
            const incompleteTasks = tasks.filter(t => !t.completed);
            const completedTasks = tasks.filter(t => t.completed);

            // Function to render a section
            const renderSection = (title, taskArray, bgColor) => {
                if (taskArray.length === 0) {
                    const emptyMessage = document.createElement('p');
                    emptyMessage.className = 'text-center text-gray-500 py-4 italic';
                    emptyMessage.textContent = `No ${title.toLowerCase()} yet. Add some!`;
                    taskListContainer.appendChild(emptyMessage);
                    return;
                }
                
                const header = document.createElement('h3');
                header.className = `${bgColor} text-white font-bold p-2 mt-4 rounded-t-lg shadow-md flex justify-between items-center`;
                header.textContent = `${title} (${taskArray.length})`;
                taskListContainer.appendChild(header);

                taskArray.forEach(task => {
                    const taskElement = document.createElement('div');
                    taskElement.className = 'flex items-center justify-between p-3 border-b border-gray-200 hover:bg-gray-50 transition duration-150';
                    if (task.completed) {
                        taskElement.classList.add('bg-green-50/50', 'line-through', 'text-gray-600');
                    } else if (new Date(task.dueDate) < new Date(today)) {
                        taskElement.classList.add('bg-red-100/50');
                    }
                    
                    const nameAndDate = document.createElement('div');
                    nameAndDate.className = 'flex flex-col flex-grow truncate';
                    
                    const name = document.createElement('span');
                    name.className = 'font-semibold text-gray-800';
                    name.textContent = task.name;
                    
                    const date = document.createElement('span');
                    date.className = 'text-xs text-gray-500 mt-0.5';
                    date.textContent = `Due: ${task.dueDate === today ? 'Today' : task.dueDate}`;
                    
                    nameAndDate.appendChild(name);
                    nameAndDate.appendChild(date);
                    taskElement.appendChild(nameAndDate);

                    const actions = document.createElement('div');
                    actions.className = 'flex items-center space-x-2 ml-4';

                    // Checkbox/Toggle Button
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = `p-2 rounded-full text-white shadow-md transition duration-200 ${task.completed ? 'bg-green-500 hover:bg-green-600' : 'bg-orange-500 hover:bg-orange-600'}`;
                    toggleBtn.innerHTML = task.completed 
                        ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 14.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>` 
                        : `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>`;
                    toggleBtn.onclick = () => toggleTaskCompletion(task.id, task.completed);
                    actions.appendChild(toggleBtn);

                    // Delete Button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'text-red-500 hover:text-red-700 p-2 rounded-full transition duration-150';
                    deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
                    deleteBtn.onclick = () => deleteTask(task.id);
                    actions.appendChild(deleteBtn);

                    taskElement.appendChild(actions);
                    taskListContainer.appendChild(taskElement);
                });
            };

            renderSection('Incomplete Works (Schedule)', incompleteTasks, 'bg-orange-600');
            renderSection('Completed Works', completedTasks, 'bg-green-600');
        }


        // --- SPIN WHEEL LOGIC ---

        const getIncompleteTasks = () => tasks.filter(t => !t.completed);

        function drawWheel() {
            const spinTasks = getIncompleteTasks();
            const numSections = spinTasks.length;
            const arcSize = (2 * Math.PI) / numSections;
            const radius = wheelCanvas.width / 2;
            const colors = ['#f97316', '#3b82f6', '#fcd34d', '#10b981', '#ef4444', '#a855f7']; // Orange, Blue, Yellow, Green, Red, Purple

            ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;

            spinTasks.forEach((task, i) => {
                const startAngle = i * arcSize;
                const endAngle = (i + 1) * arcSize;
                const color = colors[i % colors.length];

                // Draw section
                ctx.beginPath();
                ctx.arc(radius, radius, radius - 2, startAngle, endAngle);
                ctx.lineTo(radius, radius);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.stroke();

                // Draw text
                ctx.save();
                ctx.translate(radius, radius);
                ctx.rotate(startAngle + arcSize / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.font = '12px Inter, sans-serif';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.fillText(task.name.substring(0, 15), radius * 0.9, 10);
                ctx.restore();
            });

            // Draw center dot
            ctx.beginPath();
            ctx.arc(radius, radius, 15, 0, 2 * Math.PI);
            ctx.fillStyle = '#334155';
            ctx.fill();

            // Draw indicator arrow (at the top)
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(radius - 10, 0);
            ctx.lineTo(radius + 10, 0);
            ctx.lineTo(radius, 25);
            ctx.closePath();
            ctx.fill();

            if (numSections === 0) {
                ctx.fillStyle = '#334155';
                ctx.font = '16px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Add tasks to spin!', radius, radius);
            }
        }

        let isSpinning = false;
        let currentRotation = 0;

        function spinWheel() {
            if (isSpinning) return;
            const spinTasks = getIncompleteTasks();
            if (spinTasks.length === 0) {
                resultDisplay.textContent = "No tasks to spin! Add some incomplete works.";
                return;
            }

            isSpinning = true;
            spinButton.disabled = true;
            resultDisplay.textContent = "Spinning...";
            resultDisplay.classList.remove('text-green-600', 'text-red-500');
            resultDisplay.classList.add('text-indigo-500');


            const numSections = spinTasks.length;
            const arcSize = (2 * Math.PI) / numSections;

            // Calculate a random degree (e.g., 5-10 full rotations + a random stop point)
            const minRotations = 5;
            const maxRotations = 10;
            const randomRotation = Math.random() * 360;

            // Target angle (in radians)
            const targetAngleRad = ((minRotations + (Math.random() * (maxRotations - minRotations))) * 2 * Math.PI) + (randomRotation * (Math.PI / 180));
            
            // Convert to a normalized positive angle for stopping point calculation (360 degrees total)
            const normalizedStopAngle = 360 - (randomRotation % 360); 

            // Calculate the winning index based on the normalized stop angle (The wheel is drawn clockwise)
            const winningIndex = Math.floor(normalizedStopAngle / (360 / numSections));
            const winner = spinTasks[winningIndex];

            // Animation loop
            const startTime = Date.now();
            const duration = 5000; // 5 seconds spin

            function animateSpin() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                
                // Ease out function (to slow down at the end)
                const easing = 1 - Math.pow(1 - progress, 3); 
                
                // Calculate current rotation
                const rotation = easing * targetAngleRad;
                currentRotation = rotation;

                // Apply rotation to the canvas
                wheelCanvas.style.transform = `rotate(${rotation}rad)`;

                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    // Animation finished
                    isSpinning = false;
                    spinButton.disabled = false;
                    resultDisplay.textContent = `GO TIME: ${winner.name}!`;
                    resultDisplay.classList.remove('text-indigo-500');
                    resultDisplay.classList.add('text-green-600', 'font-bold');

                    // Small bounce effect after stop
                    wheelCanvas.style.transition = 'transform 0.2s ease-out';
                    wheelCanvas.style.transform = `rotate(${rotation + (Math.PI/180) * 5}rad)`; // 5 degree overshoot
                    setTimeout(() => {
                        wheelCanvas.style.transform = `rotate(${rotation}rad)`;
                        wheelCanvas.style.transition = 'none';
                    }, 200);
                }
            }
            animateSpin();
        }

        // --- EVENT LISTENERS AND INITIALIZATION ---
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('taskDateInput').value = today;
            document.getElementById('taskForm').addEventListener('submit', handleTaskFormSubmit);
            spinButton.addEventListener('click', spinWheel);

            // Resize observer to keep the canvas square and centered
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const size = Math.min(entry.contentRect.width, 300);
                    wheelCanvas.width = size;
                    wheelCanvas.height = size;
                    drawWheel();
                }
            });
            resizeObserver.observe(document.getElementById('wheelContainer'));
            
            initFirebase();
        });

        // Expose functions for buttons created in the render function
        window.toggleTaskCompletion = toggleTaskCompletion;
        window.deleteTask = deleteTask;

    </script>
    <style>
        /* Custom CSS for the wheel transition */
        #wheelCanvas {
            transition: transform 5s cubic-bezier(0.1, 0.9, 0.2, 1);
            will-change: transform;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen font-sans antialiased p-4 sm:p-6">
    <!-- Title and User ID -->
    <div class="max-w-4xl mx-auto mb-6 text-center">
        <h1 class="text-4xl font-extrabold text-orange-600 mb-2">Student Focus Navigator</h1>
        <p id="userIdDisplay" class="text-sm text-gray-500">Loading...</p>
        <div id="loadingIndicator" class="text-indigo-500 font-semibold mt-2">Connecting to secure storage...</div>
    </div>

    <div class="max-w-4xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-6">
        
        <!-- Task Management Section (Time Table / Works Completed/Not Completed) -->
        <div class="bg-white p-6 rounded-xl shadow-2xl border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">1. Task Manager & Schedule</h2>
            
            <!-- Task Input Form -->
            <form id="taskForm" class="flex flex-col space-y-3 mb-6 p-4 bg-gray-50 rounded-lg shadow-inner">
                <input type="text" id="taskNameInput" placeholder="Enter your assignment or study task (e.g., Calc Homework, Read Chapter 5)" required 
                       class="p-3 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 transition duration-150">
                <div class="flex space-x-2">
                    <label for="taskDateInput" class="sr-only">Due Date</label>
                    <input type="date" id="taskDateInput" required class="p-3 border border-gray-300 rounded-lg w-1/2 focus:ring-orange-500 focus:border-orange-500 transition duration-150">
                    <button type="submit" class="w-1/2 bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition duration-200 shadow-md">
                        Add Task
                    </button>
                </div>
            </form>

            <!-- Task List -->
            <div id="task-list-container" class="space-y-1">
                <!-- Tasks will be rendered here by JavaScript -->
            </div>
        </div>

        <!-- Spin Wheel Section -->
        <div id="wheelContainer" class="bg-white p-6 rounded-xl shadow-2xl border border-gray-200 flex flex-col items-center justify-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 border-b pb-2 w-full text-center">2. Spin the Wheel Decision Maker</h2>

            <canvas id="wheelCanvas" width="300" height="300" class="mb-6"></canvas>
            
            <p id="resultDisplay" class="text-center text-xl font-medium text-indigo-500 mb-4 h-10 flex items-center"></p>

            <button id="spinButton" class="bg-orange-500 text-white font-extrabold text-lg px-8 py-4 rounded-full shadow-lg hover:bg-orange-600 active:shadow-none transform hover:scale-105 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                SPIN TO CHOOSE
            </button>
            <p class="text-sm text-gray-500 mt-3 italic">Only Incomplete Tasks appear on the wheel.</p>
        </div>

    </div>
</body>
</html>
s